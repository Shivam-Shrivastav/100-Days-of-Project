# -*- coding: utf-8 -*-
"""Song Recommendation System Based on User Playlist Original.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nYnFE29EVv3OHN2IcBEpxH8LLcrMH0oc

## Installing and Importing Dependencies
"""

import pandas as pd
import numpy as np
import json
import re 
import sys
import itertools

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

!pip install spotipy
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from spotipy.oauth2 import SpotifyOAuth
import spotipy.util as util

import warnings
warnings.filterwarnings("ignore")

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""#### Max Display Disable"""

pd.set_option('display.max_columns', None)
pd.set_option("max_rows", None)

"""## Importing Dataset of the tracks """

df = pd.read_csv('/content/drive/MyDrive/tracks.csv')
df.head()

"""There is nothing here related to the genre of the song which will be useful. This data alone won't help us find relavent content since this is a content based recommendation system. Fortunately there is a artist.csv file that should have some useful information

## Importing Dataset of the artist and genres
"""

df_genres = pd.read_csv('/content/drive/MyDrive/data_by_artist_o.csv')
df_genres.tail()

"""The genres are going to be really useful here and I'll need to use it moving forward. Now, the genre column appears to be in a list format but my past experience tells me that it's likely not. Let's investigate this further."""

df_genres.dtypes

df_genres.shape

df.shape

df_genres['genres'].tail()

df_genres['genres_upd'] = df_genres['genres'].apply(lambda x:[re.sub(' ', '_', i) for i in re.findall(r"'([^']*)'", x)])

df_genres['genres_upd'].tail().values[1][0]

# Now, if you recall, this data is at a artist level and the previous dataset is at a song level. So what here's what we need to do:

# Explode artists column in the previous so each artist within a song will have their own row
# Merge data_w_genre to the exploded dataset in Step 1 so that the previous dataset no is enriched with genre dataset

df['artists_upd_v1'] = df['artists'].apply(lambda x: re.findall(r"'([^']*)'", x))

df['artists_upd_v1'].values[0]

df[df['artists_upd_v1'].apply(lambda x: not x)].head(5)

df['artists_upd_v2'] = df['artists'].apply(lambda x: re.findall('\"(.*?)\"',x))
df['artists_upd'] = np.where(df['artists_upd_v1'].apply(lambda x: not x), df['artists_upd_v2'], df['artists_upd_v1'] )

for i in range(0, len(df['name'])):
    if type(df['name'][i]) == float:
        df['name'][i]= str(df['name'][i])

df['artists_song'] = df.apply(lambda row: row['artists_upd'][0]+row['name'],axis = 1)

df[df['name']=='Adore You']

df.drop_duplicates('artists_song',inplace = True)

df[df['name']=='Adore You']

artists_exploded = df[['artists_upd','id']].explode('artists_upd')

artists_exploded.head()

artists_exploded_enriched = artists_exploded.merge(df_genres, how = 'left', left_on = 'artists_upd',right_on = 'artists')
artists_exploded_enriched_nonnull = artists_exploded_enriched[~artists_exploded_enriched.genres_upd.isnull()]

artists_exploded_enriched.head()

artists_exploded_enriched_nonnull[artists_exploded_enriched_nonnull['id'] =='6KuQTIu1KoTTkLXKrwlLPV']

artists_genres_consolidated = artists_exploded_enriched_nonnull.groupby('id')['genres_upd'].apply(list).reset_index()

artists_genres_consolidated['consolidates_genre_lists'] = artists_genres_consolidated['genres_upd'].apply(lambda x: list(set(list(itertools.chain.from_iterable(x)))))

artists_genres_consolidated['consolidates_genre_lists'][0]

artists_genres_consolidated['genres_upd'][0]

df = df.merge(artists_genres_consolidated[['id','consolidates_genre_lists']], on = 'id',how = 'left')

"""#### Here we have dataset of the tracks with consolidated genres in it and we are going to use this dataset for making recognition system"""

df.head()

## 2. Feature Engineering

### - Normalize float variables
### - OHE Year and Popularity Variables
### - Create TF-IDF features off of artist genres

"""##### You can go through their explanation in the given links below:

- [OHE EXPLANATION](https://www.geeksforgeeks.org/ml-one-hot-encoding-of-datasets-in-python/)
- [TF-IDF EXPLANATION](https://towardsdatascience.com/tf-idf-for-document-ranking-from-scratch-in-python-on-real-world-dataset-796d339a4089#:~:text=TF%2DIDF%20stands%20for%20%E2%80%9CTerm,Information%20Retrieval%20and%20Text%20Mining.)
"""

df.tail()

df['year'] = df['release_date'].apply(lambda x: x.split('-')[0])

float_cols = df.dtypes[df.dtypes== 'float64'].index.values

ohe_cols = 'popularity'

df['popularity'].describe()

# create 5 point buckets for popularity 
df['popularity_red'] = df['popularity'].apply(lambda x: int(x/5))

# tfidf can't handle nulls so fill any null values with an empty list
df['consolidates_genre_lists'] = df['consolidates_genre_lists'].apply(lambda d: d if isinstance(d, list) else [])

df.head()

#simple function to create OHE features
#this gets passed later on
def ohe_prep(df, column, new_name): 
    """ 
    Create One Hot Encoded features of a specific column

    Parameters: 
        df (pandas dataframe): Spotify Dataframe
        column (str): Column to be processed
        new_name (str): new column name to be used
        
    Returns: 
        tf_df: One hot encoded features 
    """
    
    tf_df = pd.get_dummies(df[column])
    feature_names = tf_df.columns
    tf_df.columns = [new_name + "|" + str(i) for i in feature_names]
    tf_df.reset_index(drop = True, inplace = True)    
    return tf_df

#function to build entire feature set
def create_feature_set(df, float_cols):
    """ 
    Process spotify df to create a final set of features that will be used to generate recommendations

    Parameters: 
        df (pandas dataframe): Spotify Dataframe
        float_cols (list(str)): List of float columns that will be scaled 
        
    Returns: 
        final: final set of features 
    """
    
    #tfidf genre lists
    tfidf = TfidfVectorizer()
    tfidf_matrix =  tfidf.fit_transform(df['consolidates_genre_lists'].apply(lambda x: " ".join(x)))
    genre_df = pd.DataFrame(tfidf_matrix.toarray())
    genre_df.columns = ['genre' + "|" + i for i in tfidf.get_feature_names()]
    genre_df.reset_index(drop = True, inplace=True)

    #explicity_ohe = ohe_prep(df, 'explicit','exp')    
    year_ohe = ohe_prep(df, 'year','year') * 0.5
    popularity_ohe = ohe_prep(df, 'popularity_red','pop') * 0.15

    #scale float columns
    floats = df[float_cols].reset_index(drop = True)
    scaler = MinMaxScaler()
    floats_scaled = pd.DataFrame(scaler.fit_transform(floats), columns = floats.columns) * 0.2

    #concanenate all features
    final = pd.concat([genre_df, floats_scaled, popularity_ohe, year_ohe], axis = 1)
     
    #add song id
    final['id']=df['id'].values
    
    return final

"""###### Since my system wasn't able to process on 523475 songs therefore slice the data to new songs (starts from 2010s)"""

dfs = df[400000:523475]  
# dfs.shape

complete_feature_set = create_feature_set(dfs, float_cols=float_cols)#.mean(axis = 0)

"""##### The complete feature of our songs dataset which are really useful to us further"""

complete_feature_set.shape

"""## Spotify API Authorization
##### Here we are using spotify api to access the playlist of the user from which the model we get to know the taste of the user and will predict song according to his/her taste
"""

#client id and secret for my application
client_id = 'b6221c7c43b0446999bbd1d314fd3f3f'
client_secret= 'e6a0b689efc546f2b44ba71b246106b1'

scope = 'user-library-read'

if len(sys.argv) > 1:
    username = sys.argv[1]
else:
    print("Usage: %s username" % (sys.argv[0],))
    sys.exit()

auth_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
sp = spotipy.Spotify(auth_manager=auth_manager)

# token = util.prompt_for_user_token(scope, client_id= client_id, client_secret=client_secret, redirect_uri='http://www.google.com/')

token = 'BQAClwRqsocKbHm0kl0_TnBDiPC3p0od9Qf70H20XKZXxLABbnQ2CoIW7hRF96vpYCERKeuIiFztiigiMx2t3mcZ-8qAVlH809yTIzCpy-RG-74ymFyzUfnDb1dLKGRcVUpISqsqegi0NKuuuzxPZr_An594oKjj87pmPM_KnMzE0Ag8&token_type=Bearer&expires_in=3600'

sp = spotipy.Spotify(auth=token)

#gather playlist names and images. 
#images aren't going to be used until I start building a UI
id_name = {}
list_photo = {}
for i in sp.current_user_playlists()['items']:

    id_name[i['name']] = i['uri'].split(':')[2]
    list_photo[i['uri'].split(':')[2]] = i['images'][0]['url']

"""##### Playlists made by the user"""

id_name

def create_necessary_outputs(playlist_name,id_dic, df):
    """ 
    Pull songs from a specific playlist.

    Parameters: 
        playlist_name (str): name of the playlist you'd like to pull from the spotify API
        id_dic (dic): dictionary that maps playlist_name to playlist_id
        df (pandas dataframe): spotify datafram
        
    Returns: 
        playlist: all songs in the playlist THAT ARE AVAILABLE IN THE KAGGLE DATASET
    """
    
    #generate playlist dataframe
    playlist = pd.DataFrame()
    playlist_name = playlist_name

    for ix, i in enumerate(sp.playlist(id_dic[playlist_name])['tracks']['items']):
        #print(i['track']['artists'][0]['name'])
        playlist.loc[ix, 'artist'] = i['track']['artists'][0]['name']
        playlist.loc[ix, 'name'] = i['track']['name']
        playlist.loc[ix, 'id'] = i['track']['id'] # ['uri'].split(':')[2]
        playlist.loc[ix, 'url'] = i['track']['album']['images'][1]['url']
        playlist.loc[ix, 'date_added'] = i['added_at']

    playlist['date_added'] = pd.to_datetime(playlist['date_added'])  
    
    playlist = playlist[playlist['id'].isin(df['id'].values)].sort_values('date_added',ascending = False)
    
    return playlist

"""###### We are going to work on his Soothing song playlist"""

playlist_vibrant = create_necessary_outputs('Soothing Songs', id_name,df)
#playlist_chill = create_necessary_outputs('chill',id_name, spotify_df)
#playlist_classical = create_necessary_outputs('Epic Classical',id_name, spotify_df)

from skimage import io
import matplotlib.pyplot as plt

def visualize_songs(df):
    """ 
    Visualize cover art of the songs in the inputted dataframe

    Parameters: 
        df (pandas dataframe): Playlist Dataframe
    """
    
    temp = df['url'].values
    plt.figure(figsize=(20, 1.3*int(len(temp))))
    columns = 4
    
    for i, url in enumerate(temp):
        plt.subplot(len(temp) / columns + 1, columns, i + 1)

        image = io.imread(url)
        plt.imshow(image)
        plt.xticks(color = 'w', fontsize = 0.1)
        plt.yticks(color = 'w', fontsize = 0.1)
        plt.xlabel(df['name'].values[i], fontsize = 20)
        plt.tight_layout(h_pad=0.5, w_pad=0.5)
        plt.subplots_adjust(wspace=None, hspace=None)

    plt.show()

"""###### Songs in the soothing songs playlist"""

playlist_vibrant

visualize_songs(playlist_vibrant)

"""##### We are generating the features of the user playlist as we have done for the above dataset
###### We are doing this by just comparing the id of the song present in the user playlist with the id of the songs present in our dataset and naming them as complete_feature_set_playlist_vector(USER PLAYLIST FEATURE DF) and  complete_feature_set_nonplaylist(ORIGINAL DATASET FEATURE DF)
"""

def generate_playlist_feature(complete_feature_set, playlist_df, weight_factor):
    """ 
    Summarize a user's playlist into a single vector

    Parameters: 
        complete_feature_set (pandas dataframe): Dataframe which includes all of the features for the spotify songs
        playlist_df (pandas dataframe): playlist dataframe
        weight_factor (float): float value that represents the recency bias. The larger the recency bias, the most priority recent songs get. Value should be close to 1. 
        
    Returns: 
        playlist_feature_set_weighted_final (pandas series): single feature that summarizes the playlist
        complete_feature_set_nonplaylist (pandas dataframe): 
    """
    
    complete_feature_set_playlist = complete_feature_set[complete_feature_set['id'].isin(playlist_df['id'].values)]#.drop('id', axis = 1).mean(axis =0)
    complete_feature_set_playlist = complete_feature_set_playlist.merge(playlist_df[['id','date_added']], on = 'id', how = 'inner')
    complete_feature_set_nonplaylist = complete_feature_set[~complete_feature_set['id'].isin(playlist_df['id'].values)]#.drop('id', axis = 1)
    
    playlist_feature_set = complete_feature_set_playlist.sort_values('date_added',ascending=False)

    most_recent_date = playlist_feature_set.iloc[0,-1]
    
    for ix, row in playlist_feature_set.iterrows():
        playlist_feature_set.loc[ix,'months_from_recent'] = int((most_recent_date.to_pydatetime() - row.iloc[-1].to_pydatetime()).days / 30)
        
    playlist_feature_set['weight'] = playlist_feature_set['months_from_recent'].apply(lambda x: weight_factor ** (-x))
    
    playlist_feature_set_weighted = playlist_feature_set.copy()
    #print(playlist_feature_set_weighted.iloc[:,:-4].columns)
    playlist_feature_set_weighted.update(playlist_feature_set_weighted.iloc[:,:-4].mul(playlist_feature_set_weighted.weight,0))
    playlist_feature_set_weighted_final = playlist_feature_set_weighted.iloc[:, :-4]
    #playlist_feature_set_weighted_final['id'] = playlist_feature_set['id']
    
    return playlist_feature_set_weighted_final.sum(axis = 0), complete_feature_set_nonplaylist

complete_feature_set_playlist_vector_EDM, complete_feature_set_nonplaylist_EDM = generate_playlist_feature(complete_feature_set, playlist_vibrant, 1.09)
#complete_feature_set_playlist_vector_chill, complete_feature_set_nonplaylist_chill = generate_playlist_feature(complete_feature_set, playlist_chill, 1.09)

complete_feature_set_playlist_vector_EDM.shape

"""#### Here we are finding the similar songs according to user playlist with the help of [COSINE SIMILARITY](https://towardsdatascience.com/understanding-cosine-similarity-and-its-application-fd42f585296a)

"""

def generate_playlist_recos(df, features, nonplaylist_features):
    """ 
    Pull songs from a specific playlist.

    Parameters: 
        df (pandas dataframe): spotify dataframe
        features (pandas series): summarized playlist feature
        nonplaylist_features (pandas dataframe): feature set of songs that are not in the selected playlist
        
    Returns: 
        non_playlist_df_top_40: Top 40 recommendations for that playlist
    """
    
    non_playlist_df = df[df['id'].isin(nonplaylist_features['id'].values)]
    non_playlist_df['sim'] = cosine_similarity(nonplaylist_features.drop('id', axis = 1).values, features.values.reshape(1, -1))[:,0]
    non_playlist_df_top_40 = non_playlist_df.sort_values('sim',ascending = False).head(40)
    non_playlist_df_top_40['url'] = non_playlist_df_top_40['id'].apply(lambda x: sp.track(x)['album']['images'][1]['url'])
    
    return non_playlist_df_top_40

"""#### Here are the top 40 songs recommended by the model"""

edm_top40 = generate_playlist_recos(df, complete_feature_set_playlist_vector_EDM, complete_feature_set_nonplaylist_EDM)

edm_top40

visualize_songs(edm_top40)

